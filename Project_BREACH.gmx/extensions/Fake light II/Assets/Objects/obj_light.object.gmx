<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-900</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Surface is created here. It only covers the view, not the whole room.
Surf_Light = surface_create(view_wview[0],view_hview[0])

//Array of objects that generates light.

Item[0,0] = obj_player; //Source of light.
Item[0,1] = spr_cone; //sprite to use (Always use white sprite with gradient for best result.)
Item[0,2] = 1; // Xscale factor of the sprite.
Item[0,3] = 1; // Yscale factor of the sprite.
Item[0,4] = c_black; // The light color. (Black is no color.)
Item[0,5] = 1; //Flickering. That affects the size of BOTH Xscale and Yscale.

Item[1,0] = obj_blue_fire;
Item[1,1] = spr_gradient;
Item[1,2] = 2;
Item[1,3] = 2;
Item[1,4] = c_teal;
Item[1,5] = 1.1; //Flicker to the outside

Item[2,0] = obj_red_fire;
Item[2,1] = spr_gradient;
Item[2,2] = 1;
Item[2,3] = 1;
Item[2,4] = c_red;
Item[2,5] = 1;

Item[3,0] = obj_lantern;
Item[3,1] = spr_gradient;
Item[3,2] = 1;
Item[3,3] = 1.5;
Item[3,4] = c_yellow ;
Item[3,5] = 1;

Item[4,0] = obj_green_fire;
Item[4,1] = spr_gradient;
Item[4,2] = 1.5;
Item[4,3] = 1.5;
Item[4,4] = c_lime;
Item[4,5] = 0.8; //Flicker on the inside

/*
If you want another object, increment the first dimension of the array like this:
Item[5,0] = 
Item[5,1] = 
Item[5,2] = 
Item[5,3] = 
Item[5,4] = 
Item[5,5] = 
*/


//That part set the max range of all lights.
var count = 0;

repeat(array_height_2d(Item))
{
Item[count,6] = scr_max_range(Item[count,1], Item[count,2], Item[count,3], Item[count,5]); //See inside scipt for description
count++;
}


//DAY/NIGHT CYCLE//

/*1440 minutes/days. 0 is 12am, 1439 is 11h59pm.
Alpha value of darkness is 0.9 by night and 0 by day.
Rising sun is between 300 and 480 (5am to 8 am)
Sunset if from 1140 1320 (7pm to 22pm)
*/

Blackness_Value = 0.9; //The alpha value of the 'darkness'

Cycle[0] = 0//start time
Cycle[1] = 300//Rising sun
Cycle[2] = 480//Day
Cycle[3] = 1140//Sunset
Cycle[4] = 1320//Night
Cycle[5] = 0//Day alpha
Cycle[6] = 1//Night alpha
//The day and night alpha value is the alpha value of the drawn surface, not the 'darkness'.

C_Time = Cycle[0] //Set C_Time at start time.

/*
Blackness_Value and Cycle[6] have 2 differents purpose.
Blackness_Value set the maximum darkness.
Cylcle[6] is the alpha of the surface with all the lights and darkness.







































</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
We increment C_Time by 1 each step. (1 minute each step)
If you want a slower timer, you could use an alarm that loop each X steps.
*/

C_Time = (C_Time + 1) mod 1440;

surface_set_target(Surf_Light);

draw_clear_alpha(c_black, Blackness_Value); //The opacity of the darkness is set here.

var count, l_source, l_sprite, l_xscale, l_yscale, l_color, l_flick, l_flick_id, l_max_range;

//That part will loops through all objects listed on the array.
count = 0;
var xx, yy;
repeat(array_height_2d(Item))
{
l_source = Item[count,0];
l_sprite = Item[count,1];
l_xscale = Item[count,2];
l_yscale = Item[count,3];
l_color = Item[count,4];
l_flick_id = Item[count,5];
l_max_range = Item[count, 6];

    with(l_source)
    {
        if scr_is_on_view(0, l_max_range) //See inside script for description
        {
        xx = x-view_xview[0];
        yy = y-view_yview[0];
        l_flick = choose(1, 1, 1, 1, 1, 1, l_flick_id); //You can add or remove some '1'.
        draw_set_blend_mode(bm_subtract); //Punch a gradient hole
        draw_sprite_ext(l_sprite, 0, xx, yy, l_xscale*l_flick, l_yscale*l_flick, c_rotation, c_black, 1);
        draw_set_blend_mode(bm_zero); //Add some color
        draw_sprite_ext(l_sprite, 0, xx, yy, l_xscale*l_flick, l_yscale*l_flick, c_rotation, l_color, 0.5); //You can change the last argument here.        
        }
    }
    
count++;
}

draw_set_blend_mode(bm_normal);
surface_reset_target();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_free(Surf_Light); //Good habits!
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw the timer
draw_set_color(c_white);
draw_set_valign(fa_center);
draw_set_halign(fa_left);

var hour, minute;
hour = C_Time div 60;
minute = C_Time mod 60;


draw_text(view_xview[0]+12, view_yview[0]+12, string(hour div 10)+ string(hour mod 10)+':'+string(minute div 10)+string(minute mod 10));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var surf_alpha = scr_day_night_alpha(); //That line adjusts the alpha value of the whole surface.

if(surf_alpha == 0)
{
exit; //The surface is invisible, no need to draw it.
}


if(surface_exists(Surf_Light)) //A safe way to draw a surface: Make sure it exists.
{
draw_surface_ext(Surf_Light, view_xview[0], view_yview[0], 1, 1, 0, c_white, surf_alpha); //We use our alpha value right here: surf_alpha.
}
else
{
Surf_Light = surface_create(view_wview[0],view_hview[0]);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//A very interesting function to restart the game ;)
game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
